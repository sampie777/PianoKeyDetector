import time
from typing import Optional

import project_state
from utils import *

logger = logging.getLogger(__name__)

last_calibrated = time.time()
no_more_contours_found_time: Optional[float] = None
mouse_position: tuple = (0, 0)
mouse_clicks: List[tuple] = []
is_mouse_zone_calibration_done: bool = False
is_zone_calibration_done: bool = False


def paint_calibration_status_text(frame, text):
    cv2.rectangle(frame, (0, 0), (140, 80), (255, 255, 255), -1, lineType=Config.line_type)
    cv2.putText(frame, text, (10, 60), Config.font_family, 2, (0, 0, 0), 2, lineType=Config.line_type)


def calibrate_key(frame, key: Key, current_frame_index):
    global last_calibrated, no_more_contours_found_time

    # PROCESSING PART
    contours, zone, differences, thresh = get_contours_in_frame(frame)
    contour_centers = get_contours_centers(contours)

    if current_frame_index < Config.skip_to_time * project_state.fps:
        return True

    if last_calibrated + Config.calibration_delay_between_keys + Config.calibration_key_start_delay < time.time():
        add_contour_centers_to_key_points(contour_centers, key)

        check_if_calibration_is_done(contours, key)

    # PAINT PART
    if last_calibrated + Config.calibration_delay_between_keys > time.time():
        paint_calibration_status_text(frame, "")
    else:
        paint_calibration_status_text(frame, key.name)

    paint_keys_points(zone)
    paint_contour_outlines(zone, contours)
    paint_contour_centers(zone, contour_centers)
    paint_key_name(zone, key, text_margin=Config.text_distance_to_key)

    return show_image(frame)


def check_if_calibration_is_done(contours, key):
    global no_more_contours_found_time, last_calibrated

    if len(contours) > 0 or len(key.points) == 0:
        return

    if no_more_contours_found_time is None:
        no_more_contours_found_time = time.time()
        return

    if no_more_contours_found_time + Config.calibration_key_stop_delay > time.time():
        return

    no_more_contours_found_time = None
    last_calibrated = time.time()

    filter_points_for_key(key)

    if len(key.points) == 0:
        logger.warning("All points are filtered out for key {}. Retrying.".format(key))
        return

    create_line_for_key(key)

    if key.line is None:
        logger.warning("Could not get a line for key {}. Retrying.".format(key))
        key.points.clear()
        return

    key.is_calibrated = True
    logger.info("Key {} calibrated. Delaying for: {} ms"
                .format(key, Config.calibration_delay_between_keys))


def get_contours_centers(contours: np.ndarray):
    return list(get_contour_center(contour) for contour in contours)


def add_contour_centers_to_key_points(contour_centers, key):
    for center in contour_centers:
        if center in key.points:
            continue
        key.points.append(center)


def create_line_for_key(key: Key):
    logger.info("Creating line for key: {}".format(key))
    if len(key.points) < 2:
        return

    xs = []
    ys = []
    for point in key.points:
        xs.append(point[0])
        ys.append(point[1])
    xs = np.array(xs)
    ys = np.array(ys)

    m, b = np.polyfit(xs, ys, 1)[:2]

    x_min = xs.min(initial=None)
    y_min = m * x_min + b
    x_max = xs.max(initial=None)
    y_max = m * x_max + b

    key.line = [
        (round(x_min), round(y_min)),
        (round(x_max), round(y_max)),
    ]


def filter_points_for_key(key: Key):
    logger.info("Applying points filter for key: {}".format(key))

    a = 2
    mean = np.mean(key.points, axis=0)

    if Config.key_points_filter_standard_deviation is not None:
        std = Config.key_points_filter_standard_deviation
    else:
        std = np.std(key.points, axis=0)

    filtered_points = []
    for point in key.points:
        if not (mean[0] + a * std[0] > point[0] > mean[0] - a * std[0]):
            continue
        if not (mean[1] + a * std[1] > point[1] > mean[1] - a * std[1]):
            continue

        filtered_points.append(point)
    key.points = filtered_points


def loop(frame, current_frame_index: int = -1) -> bool:
    if not is_zone_calibration_done:
        return calibrate_zone_bounds(frame)

    # Get next key to calibrate
    try:
        key_to_calibrate = next(key for key in keys if not key.is_calibrated)
    except StopIteration:
        logger.info("Calibration is done")
        Config.calibrating = False
        print_calibrated_keys()
        return True

    return calibrate_key(frame, key_to_calibrate, current_frame_index)


def print_calibrated_keys():
    print("\n\n# Keys. Generated by profile: {}".format(Config.profile.name))
    print("keys = [")
    for key in keys:
        print("    Key(\"{}\", is_calibrated={}, color=({}), line={}),"
              .format(key.name,
                      key.is_calibrated,
                      ', '.join(str(round(color)) for color in key.color),
                      key.line))
    print("]\n")


def print_calibrated_zone():
    print("\n\n# Zone. Generated by profile: {}".format(Config.profile.name))
    print("zone_bounds = {},".format(
        ndarray_to_string(project_state.zone_bounds) if project_state.zone_bounds is not None else None))
    print("mask_area = np.array({}),".format(
        ndarray_to_string(project_state.mask_area) if project_state.mask_area is not None else None))
    print("\n")


def calibrate_zone_bounds(frame: np.ndarray):
    global is_zone_calibration_done

    # PROCESSING PART
    logger.info("Going in endless loop for calibrating zone")
    while not is_zone_calibration_done:
        freeze_frame = frame.copy()

        if is_mouse_zone_calibration_done:
            mouse_contour = np.array(mouse_clicks)
            create_zone_and_mask_from_contour(mouse_contour)

            # (1) so the zone cut can be done when the zone bounds are available
            set_background_image(None)
            get_contours_in_frame(frame)

        # PAINT PART
        draw_mouse_points(freeze_frame)

        if not show_image(freeze_frame):
            return False
    return True


def create_zone_and_mask_from_contour(mouse_contour):
    global is_zone_calibration_done

    # Zone
    (x, y, w, h) = cv2.boundingRect(mouse_contour)
    project_state.zone_bounds = np.array([
        [x, y],
        [x + w, y + h],
    ])

    # Mask
    project_state.mask_area = np.subtract(mouse_contour, [x, y])

    is_zone_calibration_done = True
    print_calibrated_zone()


def draw_mouse_points(frame):
    if len(mouse_clicks) == 0:
        return

    predicted_contour = np.array(mouse_clicks + [mouse_position])
    cv2.drawContours(frame, [predicted_contour], 0, (255, 255, 255), 2, lineType=Config.line_type)

    # Mark points with circle
    for point in mouse_clicks:
        cv2.circle(frame, point, 4, (255, 0, 255), -1, lineType=Config.line_type)


def on_mouse_event_calibrate_zone(event, x, y, flags, param):
    global mouse_position, is_mouse_zone_calibration_done

    if is_mouse_zone_calibration_done or is_zone_calibration_done:
        return

    mouse_position = (x, y)

    if event == cv2.EVENT_LBUTTONUP:
        logger.info("Mouse click at: {}, {}".format(*mouse_position))
        if mouse_position not in mouse_clicks:
            mouse_clicks.append(mouse_position)

    if event == cv2.EVENT_LBUTTONDBLCLK:
        logger.info("Mouse double click at: {}, {}".format(*mouse_position))
        if len(mouse_clicks) > 2:
            is_mouse_zone_calibration_done = True
        else:
            logger.info(
                    "Can't stop mouse calibration. 3 or more points are needed. Currently only {} points calibrated."
                        .format(len(mouse_clicks)))


def setup():
    global is_zone_calibration_done
    is_zone_calibration_done = not Config.calibrate_zone

    cv2.setMouseCallback(Config.preview_window_title, on_mouse_event_calibrate_zone)
