import time
from typing import Optional

import project_state
from utils import *

logger = logging.getLogger(__name__)

last_calibrated = time.time()
no_more_contours_found_time: Optional[float] = None
mouse_position: tuple = (0, 0)
mouse_clicks: List[tuple] = []
is_mouse_zone_calibration_done: bool = False


def paint_calibration_status_text(frame, text):
    cv2.rectangle(frame, (0, 0), (140, 80), (255, 255, 255), -1, lineType=Config.line_type)
    cv2.putText(frame, text, (10, 60), Config.font_family, 2, (0, 0, 0), 2, lineType=Config.line_type)


def calibrate_key(frame, key: Key):
    global last_calibrated, no_more_contours_found_time

    # PROCESSING PART
    contours, zone, differences, thresh = get_contours_in_frame(frame)
    contour_centers = get_contours_centers(contours)

    if last_calibrated + Config.calibration_delay_between_keys + Config.calibration_key_start_delay < time.time():
        add_contour_centers_to_key_points(contour_centers, key)

        check_if_calibration_is_done(contours, key)

    # PAINT PART
    if last_calibrated + Config.calibration_delay_between_keys > time.time():
        paint_calibration_status_text(zone, "")
    else:
        paint_calibration_status_text(zone, key.name)

    paint_keys_points(zone)
    paint_contour_outlines(zone, contours)
    paint_contour_centers(zone, contour_centers)
    paint_key_name(zone, key, text_margin=Config.text_distance_to_key)

    # paint_keys_points(frame, offset=Config.zone_bounds[0])
    # paint_contour_outlines(frame, contours, offset=Config.zone_bounds[0])
    # paint_contour_centers(frame, contour_centers, offset=Config.zone_bounds[0])
    # paint_key_name(frame, key, text_margin=Config.text_distance_to_key, offset=Config.zone_bounds[0])

    return show_image(frame)


def check_if_calibration_is_done(contours, key):
    global no_more_contours_found_time, last_calibrated

    if len(contours) > 0 or len(key.points) == 0:
        return

    if no_more_contours_found_time is None:
        no_more_contours_found_time = time.time()
        return

    if no_more_contours_found_time + Config.calibration_key_stop_delay > time.time():
        return

    no_more_contours_found_time = None
    last_calibrated = time.time()

    filter_points_for_key(key)

    if len(key.points) == 0:
        logger.warning("All points are filtered out for key {}. Retrying.".format(key))
        return

    create_line_for_key(key)

    if key.line is None:
        logger.warning("Could not get a line for key {}. Retrying.".format(key))
        key.points.clear()
        return

    key.is_calibrated = True
    logger.info("Key {} calibrated. Delaying for: {} ms"
                .format(key, Config.calibration_delay_between_keys))


def get_contours_centers(contours: np.ndarray):
    return list(get_contour_center(contour) for contour in contours)


def add_contour_centers_to_key_points(contour_centers, key):
    for center in contour_centers:
        if center in key.points:
            continue
        key.points.append(center)


def create_line_for_key(key: Key):
    logger.info("Creating line for key: {}".format(key))
    if len(key.points) < 2:
        return

    xs = []
    ys = []
    for point in key.points:
        xs.append(point[0])
        ys.append(point[1])
    xs = np.array(xs)
    ys = np.array(ys)

    m, b = np.polyfit(xs, ys, 1)[:2]

    x_min = xs.min(initial=None)
    y_min = m * x_min + b
    x_max = xs.max(initial=None)
    y_max = m * x_max + b

    key.line = [
        (round(x_min), round(y_min)),
        (round(x_max), round(y_max)),
    ]


def filter_points_for_key(key: Key):
    logger.info("Applying points filter for key: {}".format(key))

    a = 2
    mean = np.mean(key.points, axis=0)

    if Config.key_points_filter_standard_deviation is not None:
        std = Config.key_points_filter_standard_deviation
    else:
        std = np.std(key.points, axis=0)

    filtered_points = []
    for point in key.points:
        if not (mean[0] + a * std[0] > point[0] > mean[0] - a * std[0]):
            continue
        if not (mean[1] + a * std[1] > point[1] > mean[1] - a * std[1]):
            continue

        filtered_points.append(point)
    key.points = filtered_points


def loop(frame, current_frame_index: int = -1) -> bool:
    if current_frame_index < 5 * 30:
        return True

    if project_state.zone_bounds is None:
        return calibrate_zone_bounds(frame)

    # Get next key to calibrate
    try:
        key_to_calibrate = next(key for key in keys if not key.is_calibrated)
    except StopIteration:
        logger.info("Calibration is done")
        return False

    if not calibrate_key(frame, key_to_calibrate):
        return False

    return True  # show_image(frame)


def print_keys():
    print("")
    print("# Generated by profile: {}".format(Config.profile.name))
    print("keys = [")
    for key in keys:
        print("Key(\"{}\", is_calibrated={}, color=({}), line={}),"
              .format(key.name,
                      key.is_calibrated,
                      ', '.join(str(round(color)) for color in key.color),
                      key.line))
    print("]")
    print("")


def calibrate_zone_bounds(frame: np.ndarray):
    # PROCESSING PART
    if is_mouse_zone_calibration_done:
        # temp
        project_state.mask_area = np.subtract(mouse_clicks, Config.zone_bounds[0])

        (x, y, w, h) = cv2.boundingRect(project_state.mask_area)

        project_state.zone_bounds = np.array([
            [x, y],
            [x + w, y],
            [x + w, y + h],
            [x, y + h],
        ])

    # PAINT PART
    draw_mouse_points(frame)

    return show_image(frame)


def draw_mouse_points(frame):
    if len(mouse_clicks) == 0:
        return

    prev_point = None
    # Connect points with line
    for point in mouse_clicks:
        if prev_point is None:
            if is_mouse_zone_calibration_done:
                prev_point = mouse_clicks[-1]
            else:
                prev_point = point
                continue

        cv2.line(frame, prev_point, point, (255, 255, 255), 2, lineType=Config.line_type)
        prev_point = point

    # Mark points with circle
    for point in mouse_clicks:
        cv2.circle(frame, point, 4, (255, 0, 255), -1, lineType=Config.line_type)

    # Draw point/line in progress
    if not is_mouse_zone_calibration_done:
        cv2.line(frame, prev_point, mouse_position, (255, 255, 255), 1, lineType=Config.line_type)

    # Draw rectangle around contour
    (x, y, w, h) = cv2.boundingRect(np.array(mouse_clicks))
    cv2.rectangle(frame, (x, y), (x + w, y + h), (255, 255, 0), 1)


def on_mouse_event_calibrate_zone(event, x, y, flags, param):
    global mouse_position, is_mouse_zone_calibration_done

    if is_mouse_zone_calibration_done:
        return

    mouse_position = (x, y)

    if event == cv2.EVENT_LBUTTONUP:
        logger.info("Mouse click at: {}, {}".format(*mouse_position))
        if mouse_position not in mouse_clicks:
            mouse_clicks.append(mouse_position)

    if event == cv2.EVENT_LBUTTONDBLCLK:
        logger.info("Mouse double click at: {}, {}".format(*mouse_position))
        if len(mouse_clicks) > 2:
            is_mouse_zone_calibration_done = True
        else:
            logger.info(
                    "Can't stop mouse calibration. 3 or more points are needed. Currently only {} points calibrated."
                        .format(len(mouse_clicks)))


def setup():
    cv2.setMouseCallback(Config.preview_window_title, on_mouse_event_calibrate_zone)
